## 기능 요구사항
- 기능 요구사항은 3단계와 같다
- 추가로 제공되는 객체 설계 힌트를 참고해 철저하게 TDD로 재구현 해본다.


## 이전 요구사항
- Direction Enum클래스도 하나의 객체인데 딱히 역할이 없는것 같다.
그렇다면 다른 부분에서 Direction의 역할을 책임지고 있다는 얘기가 될 수 있다.
- LadderGame 내부에 많은 get()을 가지고 있다.
    - 규칙4 : 한줄에 점을 하나만 찍는다.(디미터 법칙을 지키는 것을 의미한다.)
    - 해당 메소드들을 DTO에 구현해 본다.
- 방향과 관련된 역할을 Direction이 하고
 `RandomLineStrategy는 라인을 만들것인가?`에 대해 결정하는 역할을 하면 좋겠네요.
- 참고로 Stream.generate를 활용하여 일급 컬렉션의 불변성을 유지해주는 방법도 있으니 참고해보시면 좋을것 같아요.
Stream.generate및 limit 키워드로 찾아보시면 도움이 될것같습니다.
- 빈 공백이 포함되어 있는경우 제거하는 방법


#### 디미터의 법칙
- 디미터의 법칙을 따르는 형태의 코드는 다음과 같이 매우 단순하다.
`object.method(parameter)`
- 법칙을 지킬 필요가 없는 경우
    - 한편 객체가 아니라 자료구조라면 디미터의 법칙을 거론할 필요가 없다.
```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
> 위 예제가 디미터 법칙을 위반하는지 여부는 ctxt , Options , ScratchDir 이 객체인지 아니면 자료구조인지에
> 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료구조라면 당연히 내부 구조를
> 노출하므로 디미터 법칙이 적용되지 않는다.

디미터 법칙은 경우에 따라 판별이 매우 애매하므로 이분법적으로 생각하지 않도록 한다.

- 디미터 법칙을 위반한 코드 - 기차충돌
> 이 법칙을 따르지 않으면 메시지 체인(Message Chains)이란 악취가 나게된다.

디미터 법칙을 위반한 전형적인 코드의 형태는 다음과 같다.
`object.getChild().getContent().getItem().getTitle()`
getter가 줄줄이 이어진 모습이 기차와 닮아서 열차전복, 기차충돌(train wreck) 이라는 단어로 표현하기도 한다.
> 이 스타일을 따르지 않으면 '열차 전복'코드라고도 알려진 코드가 만들어진다. 바로 접근자(getter) 메서드가
> 기차 객차처럼 연이어 이어진 경우다.

> 원거리의 간접적인 객체에 메시지를 보내기 위하여(즉 , 원거리의 낯선 사람에게 이야기 하기 위해서)객체의 연결 경로를
> 따라 더 멀리 순회한다. 이러한 설계는 객체들이 어떻게 연결되어 있는지를 나타내는 특정한 구조와 결합된다.
> 프로그램 순회의 경로가 길어질수록 프로그램은 더 불안정해진다. 그 이유는 객체 구조(연결)는 변경될 수 있기 때문이다.

- 주의 : 디미터 법칙은 하나의 .을 강제하는 규칙이 아니다
디미터 법칙은 "오직 하나의 도트만을 사용하라"는 말로 요약되기도 한다. 따라서 대부분의 사람들은
자바8의 IntStream을 사용한 아래의 코드가 기차충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 것이다.
```java
IntStream.of(1, 15, 20, 3, 9)
    .filter(x -> x>10)
    .distinct()
    .count();
```
하지만 이것은 디미터 법칙을 제대로 이해하지 못한것이다. 위 코드에서 of, filter, distinct 메서드는 모두
IntStream이라는 동일한 클래스의 인스턴스를 반환한다. 즉, 이들은 IntStream의 인스턴스를 또다른
IntStream의 인스턴스로 변환한다.

따라서 이 코드는 디미터 법칙을 위반하지 않는다. 디미터 법칙은 결합도와 관련된 것이며,
이 결합도가 문제되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
IntStream의 내부 구조가 외부로 노출됐는가? 그렇지 않다. 단지 IntStream을
IntStream으로 변환할 뿐 , 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.

하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다. 기차 충돌처럼 보이는 코드라도
객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.



### 빌더 패턴

- 빌더패턴은 복잡한 객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로
분리하여, 서로 다른 표현이라도 이를 생성할수 있는 동일한 절차를 제공하는 패턴입니다.
- 빌더패터는 생성해야 되는 객체가 Optional한 속성을 많이 가질 때 비을 발휘 합니다.

- 빌더 패턴은 생성 패턴(Creational Pattern)중 하나이다.
     - 생성패턴은 인스턴스를 만드는 절차를 추상화하는 패턴입니다.
     - 생성패턴에 속하는 패턴들은 객체를 생성 합성하는 방법이나 객체의 표현방법을 시스템과 분리해 줍니다.
     - 생성 패턴은 시스템이 상속보다 복합 방법을 사용하는 방향으로 진화되어 가면서 더 중요해지고 있습니다.
- 생성패턴에서는 중요한 두가지 이슈가 있다.
    - 생성 패턴은 시스템이 어떤 Concrete Class를 사용하는지에 대한 정보를 캡슐화 합니다.
    - 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 결합하는지에 대한 부분을 완전히 가려줍니다.
- 생성 패턴을 이용하면 무엇이 생성되고 , 누가 이것들을 생성하며 이것이 어떻게 생성되는지 언제 생성할 것인지 결정하는데
유연성을 확보할 수 있게 됩니다.
